#!/usr/bin/env -S deno run --allow-all --unstable

import { Command, copySync, packageJson, PluginManifest, RollupModule } from "./_deps.ts";
import { getInternalPath, getLocaleVariable, theme, transpileCode } from "./_utils.ts";

export type BuildCommandOptions = {
  watch: boolean;
};

// #region ðŸ“Œ Command

export const build = new Command<void, void, BuildCommandOptions>()
  .name("build")
  .description("Generate the distribution files.")
  .option(
    "-w, --watch",
    "Watch for source code changes and restart process automatically.",
    { default: false },
  )
  .action(runBuild)
  .noExit();

if (import.meta.main) {
  build.parse(Deno.args);
}

async function runBuild(options: BuildCommandOptions) {
  const buildOptions = getBuildOptions();

  buildOptions.plugins.push(
    customizeLogPlugin(),
    resolveDependencyPlugin("dexie", "zod"),
    resolveJsonPlugin(),
    resolveInternalPlugin(),
    transpileCodePlugin(),
    generateManifestPlugin(),
    copyAssetsPlugin(),
    generateExamplePlugin(),
  );

  buildOptions.plugins;
  if (options.watch) {
    const watcher = RollupModule.watch({
      ...buildOptions,
      watch: {
        buildDelay: 0,
        clearScreen: true,
        skipWrite: false,
        chokidar: {
          usePolling: true,
          cwd: ".",
        },
        include: "source/**",
      },
    });
    const onSigInt = async () => {
      console.log("\nSignal received. Closing watcher...");

      await watcher.close();
      Deno.exit(0);
    };

    Deno.addSignalListener("SIGINT", onSigInt);
  } else {
    const bundle = await RollupModule.rollup(buildOptions);

    await bundle.write(buildOptions.output);
  }
}

// #endregion ðŸ“Œ Command

// #region ðŸ“Œ Settings

function getBuildOptions() {
  const { config } = packageJson;
  const input = `${config.input.dir}${config.input.file}`;
  const outputFile = `${config.output.dir}${config.output.file}`;
  const banner = [
    "/**",
    "BUNDLE FILE GENERATED BY ROLLUP.",
    `If you want to check the source code, @see {@link ${packageJson.homepage} | Plugin Repository}.`,
    "",
    `@file ${packageJson.description}`,
    `@author ${packageJson.author.name} <${packageJson.author.email}>`,
    `@version ${packageJson.version}`,
    `@license ${packageJson.license}`,
    "*/",
  ]
    .map((text) => (text === "/**" || text === "*/" ? text : ` * ${text}`))
    .join("\n") + "\n";

  interface LocalRollupOptions extends RollupModule.RollupOptions {
    plugins: RollupModule.Plugin[];
    output: RollupModule.OutputOptions;
  }
  const options: LocalRollupOptions = {
    input,
    logLevel: "debug",
    output: {
      banner,
      file: outputFile,
      format: packageJson.config.output.format as RollupModule.ModuleFormat,
      generatedCode: {
        preset: "es2015",
        constBindings: true,
      },
    },
    treeshake: {
      preset: "safest",
    },
    plugins: [],
    external: ["obsidian"],
  };

  return options;
}

// #endregion ðŸ“Œ Settings

// #region ðŸ“Œ Plugins
function customizeLogPlugin(): RollupModule.Plugin {
  return {
    name: "customize-log",
    onLog(_level, log) {
      const plugin = theme.plugin(`(${log.plugin} plugin)`);

      console.debug(`${plugin} ${log.message}`);

      return false;
    },
  };
}

function resolveDependencyPlugin(...vendor: string[]): RollupModule.Plugin {
  return {
    name: "resolve-dependency",
    resolveId: {
      order: "post",
      handler(source) {
        if (vendor.includes(source)) {
          this.debug(`Retrieving ${source} from vendor...`);

          return { id: `./vendor/${source}.js`, external: false };
        }

        return null;
      },
    },
  };
}

function resolveInternalPlugin(): RollupModule.Plugin {
  return {
    name: "resolve-internal",
    resolveId(source) {
      if (source.startsWith("@")) {
        this.debug(`Retrieving ${source}...`);
        return { id: getInternalPath(source), external: false };
      }
    },
  };
}

function resolveJsonPlugin(): RollupModule.Plugin {
  return {
    name: "resolve-json",
    transform(code, id) {
      if (!id.endsWith(".json")) return null;

      const variable = getLocaleVariable(id);
      const transformed = `const ${variable} = ${code};\n\nexport default ${variable}`;

      return { code: transformed, id };
    },
  };
}

function transpileCodePlugin(): RollupModule.Plugin {
  return {
    name: "transpile-code",
    async transform(_code, id) {
      if (id.endsWith(".ts")) {
        const transpiled = await transpileCode(id);

        return { code: transpiled };
      }
    },
  };
}

function generateManifestPlugin(): RollupModule.Plugin {
  const manifest: PluginManifest = {
    id: packageJson.name,
    name: packageJson.config.displayName,
    author: packageJson.author.name,
    version: packageJson.version,
    description: packageJson.description,
    minAppVersion: packageJson.config.obsidian.minAppVersion,
    isDesktopOnly: packageJson.config.isDesktopOnly,
    authorUrl: packageJson.author.url,
  };

  const asset: RollupModule.EmittedAsset = {
    type: "asset",
    name: "manifest",
    fileName: packageJson.config.output.assets.manifest,
    source: JSON.stringify(manifest, null, 2),
  };

  return {
    name: "generate-manifest",
    generateBundle() {
      this.debug("Generating manifest...");
      this.emitFile(asset);
    },
  };
}

function copyAssetsPlugin(): RollupModule.Plugin {
  const stylesPath = packageJson.config.input.assets.dir +
    packageJson.config.output.assets.styles;

  const asset: RollupModule.EmittedAsset = {
    type: "asset",
    name: "styles",
    fileName: packageJson.config.output.assets.styles,
    source: Deno.readTextFileSync(stylesPath),
  };

  return {
    name: "copy-assets",
    generateBundle() {
      this.debug("Copying assets");
      this.emitFile(asset);
    },
  };
}

function generateExamplePlugin(): RollupModule.Plugin {
  return {
    name: "generate-example",
    writeBundle() {
      this.debug("Copying bundled files to example vault...");

      copySync(packageJson.config.output.dir, packageJson.config.example.dir, {
        overwrite: true,
      });
    },
  };
}
// #endregion ðŸ“Œ Plugins
